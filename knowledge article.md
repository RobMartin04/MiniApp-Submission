# How I Learned Self-Handoffs in Node.js
Setting up a Node app is often the first real step a student takes in becoming a full-stack developer. In this article, I<br>describe my experience building my first Node app along and the problems I encountered, including why Agile handoffs<br> are important in full-stack development.
### My Personal Experience
When it comes to building any Node application, the first step is to install and configure node on your repository. This is<br> as easy as copy-pasting a few commands from online into your terminal. I already had some code I was going to reuse<br> from another project, so I ran the command `npm run start`, which in previous experience immediately ran the program.<br> However, I encountered an error. Node was telling me that "start" was undefined and it did not find it in any of the node<br> packages. I didn't work on fixing the issue immediately because I was hungry and the cafeteria I went to school at was<br> about to close, so being the organized college student I was (and am) I left a comment in the code to <mark>handoff my work to<br> a future, satiated me</mark>. After my meal, I quickly returned to work and fixed the issue, a missing alias in a node package and a `.env` file.

### Agile Handoffs
What exactly is a *handoff* in Agile? Why should I care about *Agile handoffs*? These are questions you might have if you<br> are just getting into full-stack development. According to this article, [Why Handoffs Are Killing your Agility](https://www.scrum.org/resources/blog/why-handoffs-are-killing-your-agility#:~:text=May%2019%2C%202025,over%20the%20fence%20to%20developers.) by Martin<br> Henshelwood, handoffs are "when one team or individual completes a task and passes it to another team for further<br> work." In the development world, handoffs are used when a piece of an application makes it through a stage of the<br> development life cycle. In my situation, I developed the code, handed it off to the testing team (me), and then to the<br> maintenance team (myself), before commiting it to my repository. You might wonder, "If I'm not working on a team,<br> should I still make handoffs to myself?" The answer is yes. Making *self-handoffs* are just as important as making handoffs<br> to a team. We know that individuals who *set goals*, such as to-do lists, make significant improvements in productivity,<br> according to [Andre Meyer](https://andre-meyer.ch/DATA/Pubs/2019_PhD_Thesis_AndreMeyer.pdf). In this study, developers were observed writing a list of goals they expected to accomplish the<br> following day. This study refered to this practice as "journaling", and the concept of self-handoffs is exactly that. Writing<br> down our *context and goals* for the next time we come back to that code is going to improve our *understanding* of where<br> we left off and where we need to be. Sometimes you aren't trying to figure out what next to build in your code, you are<br> figuring out how to fix it. According to this [blog on code comments](https://blog.submain.com/4-reasons-need-code-comments/), pseudocoding your intentions will draw your<br> attention away from the syntax and more on the problem. Lots of developers immediately jump to the conclusion that<br> their code isn't working likely to a syntax error, regardless of the error code produced. (We see this mentioned in [Andre<br> Meyer's](https://andre-meyer.ch/DATA/Pubs/2019_PhD_Thesis_AndreMeyer.pdf) reasearch article also). As developers we also occasionally forget why we wrote something. Documenting your<br> reasons for creating a method or class, can help you rediscover context to your project.

### Summary
In summary, it can be concluded that writing yourself notes and comments about what to work on next is a beneficial<br> habit and practice in developing an application. Self-handoffs are proven to be an important tool that developers have at<br> their disposal and is vital to providing context to the coding environment. Handoffs are responsible for many work related<br> benefits and cognitive functions like:
* Productivity
* Cognitive load
* Problem-solving
* Understanding

